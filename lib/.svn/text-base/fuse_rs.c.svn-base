/*
 * =====================================================================================
 *
 *       Filename:  fuse_rs.c
 *
 *    Description:  fuse request req allocate and free
 *
 *        Version:  1.0
 *        Created:  10/10/2011 06:55:17 PM
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  Heaven (), zhanwenhan@163.com
 *        Company:  NDSL
 *
 * =====================================================================================
 */

#include "fuse_rs.h"
#include "fuse_sock.h"
#include "fuse_epoll.h"

#include <assert.h>
#include <stdlib.h>

static uint64_t unique = 1;
uint64_t get_unique()
{
    return unique++;
}

void request_free_req(struct request_req *req)
{
    int empty = list_empty(&req->req_list);

    assert(empty == 1);
    --req->ctr;
    assert(req->ctr == 0);
    
    if(req->arg.in.data) free(req->arg.in.data);
        req->arg.in.data = NULL;
    if(req->arg.out.data) free(req->arg.out.data);
    req->arg.out.data = NULL;

    list_del_element(&req->list);
    
    free(req);
}
/*  
static void fuse_destroy_req(struct fuse_req *req)
{
    rb_tree_erase(&req->con->root,&req->node);
    
    if(req->inarg && req->inarg->data)
        free(req->inarg->data);
    if(req->inarg) free(req->inarg);

    if(req->outarg && req->outarg->data)
        free(req->outarg->data);
    if(req->outarg) free(req->outarg);

    if(req->arg.in.data) free(req->arg.in.data);
    if(req->arg.out.data) free(req->arg.out.data);

    list_del_element(&req->list);
    list_del_element(&req->req_list);
    
    free(req);
}
*/
/*  
void request_destroy_req(struct request_req *mreq)
{
    struct fuse_req *req,*next;
    
    list_for_each_entry_del(req,next,&mreq->req_list,list)
    {
        fuse_destroy_req(req);
    }
    
    request_free_req(mreq);
}
*/

/*
 * fs:the req next to send 
 * type:request type
 * owner:who want to allocate this req
 * _req:return
 *
 * */
int request_allocate_req(struct fuse_sock *fs,enum request_type type,void *owner,struct request_req **_req)
{
    struct request_req *req = NULL;
    
    if(!(req = calloc(1,sizeof(struct request_req)))) return -1;
    
    req->unique = get_unique();
    req->type = type;
    req->state = REQ_SENT;
    req->module = owner;
    req->ctr = 1;
    req->arg.in.data = NULL;
    req->arg.in.size = 0;
    req->arg.out.data = NULL;
    req->arg.out.size = 0;
    req->error = 0;
    list_init(&req->list);
    list_init(&req->req_list);
    req->next = fs;
    list_add_tail(&fs->pending,&req->list);

    *_req = req;
    
    return 0;
}

void rs_send(struct fuse_sock *fs,struct request_req *req)
{
    req->state = REQ_RUNNING;
    list_move(&fs->ready,&req->list);
    fuse_open_write(fs);
}
